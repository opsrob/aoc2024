#!/usr/bin/env python

"""
Each antenna is tuned to a specific frequency indicated by a single lowercase letter,
uppercase letter, or digit. You create a map (your puzzle input) of these antennas.
For example:

............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............

The signal only applies its nefarious effect at specific antinodes based on the resonant
frequencies of the antennas. In particular, an antinode occurs at any point that is
perfectly in line with two antennas of the same frequency - but only when one of the antennas
is twice as far away as the other. This means that for any pair of antennas with the same
frequency, there are two antinodes, one on either side of them.

So, for these two antennas with frequency a, they create the two antinodes marked with #:

..........
...#......
..........
....a.....
..........
.....a....
..........
......#...
..........
..........

Adding a third antenna with the same frequency creates several more antinodes. It would ideally
add four antinodes, but two are off the right side of the map, so instead it adds only two:

..........
...#......
#.........
....a.....
........a.
.....a....
..#.......
......#...
..........
..........

Antennas with different frequencies don't create antinodes; A and a count as different frequencies.
However, antinodes can occur at locations that contain antennas. In this diagram, the lone antenna 
with frequency capital A creates no antinodes but has a lowercase-a-frequency antinode at its
location:

..........
...#......
#.........
....a.....
........a.
.....a....
..#.......
......A...
..........
..........

The first example has antennas with two different frequencies, so the antinodes they create look 
like this, plus an antinode overlapping the topmost A-frequency antenna:

......#....#
...#....0...
....#0....#.
..#....0....
....0....#..
.#....A.....
...#........
#......#....
........A...
.........A..
..........#.
..........#.

Because the topmost A-frequency antenna overlaps with a 0-frequency antinode, there are 14 total
unique locations that contain an antinode within the bounds of the map.

Calculate the impact of the signal. How many unique locations within the bounds of the map
contain an antinode?
"""

def read_map(filename):
    with open(filename) as f:
        return [list(line.strip()) for line in f.readlines()]

def find_antennas(grid):
    frequencies = {}
    for y, row in enumerate(grid):
        for x, cell in enumerate(row):
            if cell != '.':
                if cell not in frequencies:
                    frequencies[cell] = []
                frequencies[cell].append((x, y))
    return frequencies

def manhattan_distance(p1, p2): #taxicab geometery
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

def is_aligned(p1, p2, p3):
    # Check if p3 lies on the line formed by p1 and p2
    # Using cross product method
    return (p2[1] - p1[1]) * (p3[0] - p1[0]) == (p3[1] - p1[1]) * (p2[0] - p1[0])

def find_antinodes(grid, antennas):
    antinodes = set()
    height = len(grid)
    width = len(grid[0])

    for freq, positions in antennas.items():
        if len(positions) < 2:
            continue

        for i, ant1 in enumerate(positions[:-1]):
            for ant2 in positions[i+1:]:
                dist = manhattan_distance(ant1, ant2)

                for y in range(height):
                    for x in range(width):
                        point = (x, y)
                        if is_aligned(ant1, ant2, point):
                            dist1 = manhattan_distance(ant1, point)
                            dist2 = manhattan_distance(ant2, point)
                            if dist1 * 2 == dist2 or dist2 * 2 == dist1:
                                antinodes.add(point)
    return antinodes

def solve(filename):
    grid = read_map(filename)
    antennas = find_antennas(grid)
    antinodes = find_antinodes(grid, antennas)
    return len(antinodes)

# Run solution
print(solve('input.txt')) # should be 364